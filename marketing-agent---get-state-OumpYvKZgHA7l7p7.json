{"createdAt":"2025-10-08T08:24:01.106Z","updatedAt":"2025-10-16T10:41:52.908Z","id":"OumpYvKZgHA7l7p7","name":"Marketing Agent - Get State","active":true,"isArchived":false,"nodes":[{"parameters":{"operation":"get","tableId":"marketing_agent_chats","filters":{"conditions":[{"keyName":"chat_id","keyValue":"={{ $json.body.chat_id }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-208,16],"id":"82962c05-eaf7-446b-8e4b-06b2029bb84d","name":"Get a row","credentials":{"supabaseApi":{"id":"kTiEQ3ANtMyyNLPu","name":"Supabase account"}}},{"parameters":{"jsCode":"// n8n Function node\n// Input item shape: { state: { stack, storage, variables, ... }, ... }\n\nfunction safeGet(obj, path, def = undefined) {\n  return path.split('.').reduce((o,k)=> (o && k in o) ? o[k] : undefined, obj) ?? def;\n}\n\nconst items = $input.all().map(({json}) => {\n  const st = json.state || {};\n  const vars = st.variables || {};\n  const stack = st.stack || [];\n\n  // 1) PRIMARY: variables._memory_  (array of {role, content})\n  const mem = Array.isArray(vars._memory_) ? vars._memory_ : [];\n\n  const memMsgs = mem\n    .filter(m => m && typeof m.content === 'string' && typeof m.role === 'string')\n    .map(m => ({\n      role: m.role === 'function-call' || m.role === 'function-result' ? m.role : (m.role === 'user' ? 'user' : 'assistant'),\n      content: m.role === 'function-call' || m.role === 'function-result'\n        ? (m.role === 'function-call'\n            ? `🔧 tool call: ${m.function?.name || 'unknown'} ${JSON.stringify(m.function?.arguments || {})}`\n            : `🔧 tool result: ${typeof m.result === 'string' ? m.result : JSON.stringify(m.result)}`)\n        : m.content\n    }));\n\n  // 2) FALLBACK: vf_memory (stitched string you can display if no mem)\n  const vfMemoryStr = typeof vars.vf_memory === 'string' ? vars.vf_memory : '';\n\n  // 3) ARTIFACT: stack[].storage.output  (array of Slate-like blocks -> join lines)\n  const emailBlocks = [];\n  for (const frame of stack) {\n    const out = safeGet(frame, 'storage.output');\n    if (Array.isArray(out)) {\n      for (const block of out) {\n        const text = Array.isArray(block.children)\n          ? block.children.map(c => c?.text ?? '').join('')\n          : '';\n        emailBlocks.push(text);\n      }\n    }\n  }\n  // Clean collapsible empties and join\n  const email_markdown = emailBlocks\n    .map(s => (s || '').trim())\n    .filter(s => s.length > 0)\n    .join('\\n\\n');\n\n  // If no _memory_, try to parse vf_memory into pseudo messages\n  let messages = memMsgs;\n  if (messages.length === 0 && vfMemoryStr) {\n    // very light parser: split on newlines with \"user:\" / \"assistant:\" prefixes\n    const lines = vfMemoryStr.split('\\n');\n    const tmp = [];\n    let role = null, buf = [];\n    const flush = () => {\n      if (role && buf.length) tmp.push({ role, content: buf.join('\\n').trim() });\n      role = null; buf = [];\n    };\n    for (const line of lines) {\n      const mUser = line.match(/^\\s*user:\\s*(.*)$/i);\n      const mAsst = line.match(/^\\s*assistant:\\s*(.*)$/i);\n      const mToolC = line.match(/^\\s*function-call.*?:\\s*(.*)$/i);\n      const mToolR = line.match(/^\\s*function-result.*?:\\s*(.*)$/i);\n      if (mUser) { flush(); role = 'user'; buf.push(mUser[1]); continue; }\n      if (mAsst) { flush(); role = 'assistant'; buf.push(mAsst[1]); continue; }\n      if (mToolC) { flush(); role = 'function-call'; buf.push(mToolC[1]); continue; }\n      if (mToolR) { flush(); role = 'function-result'; buf.push(mToolR[1]); continue; }\n      // continuation of current block\n      buf.push(line);\n    }\n    flush();\n    messages = tmp.filter(m => m.content);\n  }\n\n  // As a last resort, if still empty but we have an email artifact,\n  // expose it as a single assistant message so the page shows something.\n  if (messages.length === 0 && email_markdown) {\n    messages = [{ role: 'assistant', content: email_markdown }];\n  }\n\n  return {\n    json: {\n      messages,                           // ← feed to your UI\n      final_artifacts: { email_markdown },// ← show below \"Transcript\"\n      raw: {\n        had_memory: memMsgs.length > 0,\n        used_vf_memory: messages.length && memMsgs.length === 0,\n        stack_frames: stack.length\n      }\n    }\n  };\n});\n\nreturn items;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[0,16],"id":"22d19ed1-2e65-4ac3-befb-201212e860d9","name":"Code in JavaScript"},{"parameters":{"httpMethod":"POST","path":"getMarketingAgentChatState","responseMode":"lastNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[-432,16],"id":"01fbc68f-7c96-4109-84f4-75c189319cdc","name":"Webhook","webhookId":"852aafca-5074-43da-9fe6-0867f1db9197"}],"connections":{"Get a row":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"Get a row","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"e868cb92-6072-47f8-8bdd-5c6373548ec6","triggerCount":1,"shared":[{"createdAt":"2025-10-08T08:24:01.106Z","updatedAt":"2025-10-08T08:24:01.106Z","role":"workflow:owner","workflowId":"OumpYvKZgHA7l7p7","projectId":"oeHwV8sNrbPNhUov"}],"tags":[]}